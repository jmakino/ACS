= Vectors

== A DRY Version of Modified Euler

*Dan*: Now how did we get into all this array stuff?

*Erica*: I wanted to move on to the leapfrog algorithm, but Carol
insisted on first cleaning up the modified Euler code . . .

*Carol*: . . . which we haven't done yet, but now we're all set to do so!
It is just a matter of translating the old file
<tt>euler_modified_1000_steps.rb</tt>, introducing our array notation,
just as we did for the code in <tt>euler_array_each_def.rb</tt>.

Here it is, in <tt>euler_modified_array.rb</tt>

 :inccode: .euler_modified_array.rb

And before Dan can ask me, let me run it:

 :commandoutput: ruby euler_modified_array.rb | tail -1

I will also compare it to the previous result:

 :commandoutput: ruby euler_modified_1000_steps.rb | tail -1

== Not quite DRY yet

*Dan*: Bravo!  Same answers.  And yes, the code has become shorter.
I like that.

*Erica*: Hmmm, just making a code shorter does not necessarily make
it better.  You can use semicolons to put two or three lines
on one line, but that doesn't make the code any prettier.  Most likely,
it will make the code more opaque.

In fact, I'm sorry to say, I don't find the new code easier to read.
While the old code was longer, it was very easy to see what happened.
But in the new code, there are all those <tt>[k]</tt> clumps floating around
. . .  I thought the whole point of using arrays was that we could hide
the elements of the array!

*Carol*: To some extent, we have hidden things.  The methods +map+, +each+
and <tt>each_index</tt> can be attached directly to the arrays themselves,
without showing elements.  And our use of +each+ in the print statements
shows an example where there is no ugly <tt>[k]</tt> showing up at all.
But I agree with you, we should be able to do better.

*Erica*: Can we really do much better?  An array _does_ seem to be the
natural way to represent a physical vector quantity in a computer program.
I've never seen any other way . . . ah, no, I take that back.  I once
saw a C++ program, where the writer had introduced a special vector class.

*Carol*: Can you remember what the reason was for doing so?

*Erica*: I'm not exactly sure now, but it may have had to do with making it
easier to add vectors, by overloading the <tt>+</tt> operator, and that sort
of thing.

*Carol*: That sounds exactly like what we need.  If we take a look at the
first like in our code that contains one of these ugly <tt>[k]</tt> notations
that you so disliked:

 :inccode: .euler_modified_array.rb-1

you really would like to write this as

 :inccode: .euler_modified_vector.rb-1

right?

*Erica*: Yes, that would be great!  I would _love_ to get rid of all those
<tt>[k]</tt> blocks.  In fact, I think that we _should_ get rid of
them if we want to follow the DRY principle.  Look, we have been repeating
this <tt>[k]</tt> thingy three times in one line, in our latest code!

== A First Shot at a <tt>Vector</tt> Class

*Carol*: Fair enough.  Well, it's always a good idea to start simply.
The simplest case I can think of is to add two vectors.  If we continue
to represent them as arrays, we can added arrays <tt>a1</tt> and <tt>a2</tt>
to obtain their sum +a+ as follows:

  a = []
  a1.each_index{|k| a[k] = a1[k] + a2[k]}

which includes the declaration, which is necessary if +a+ has not yet been
introduced as an array, earlier in the program.

Now what you would like to write is

  a = a1 + a2

without any further complications that include references to elements
<tt>[k]</tt> or to methods such as <tt>each_index</tt> or to a declaration
of +a+, since after all the addition of two vectors should obviously produce
a new vector.  Right?

*Erica*: It sounds too good to be true, to be able to leave out all that
crap, and to tell the computer only the minimal information needed, as if
you were writing a note for yourself on a scratch pad.  Do you really think
you can implement all that, and even do away with the need for declarations?

*Carol*: I think so.  First, let's see what happens if we don't make any
modification.  I must admit, I'm not sure what Ruby will do if we ask
it to add two arrays.  Well, let's find out:

 :commandinputoutputnoecho: irb END
a1 = [1, 2, 3]
a2 = [5, 6, 7]
a = a1 + a2
quit
END

*Dan*: I guess that is _one_ way to add two arrays, to just put them end
to end, and string all the elements together.  And for many applications
that might just be the right thing to do, for example, if you have an array
of the names of countries in a nation, and you want to add a few more names.
But in our case, this is not what we want.  We'd better get:

  a = [1+5, 2+6, 3+7] = [6, 8, 10]

*Carol*: In an object-oriented language like Ruby, this means that we
need to introduce a new type of object.  In other words, we need to
introduce a new class.  Ruby has the convention that class names start
with a capital, so a natural name for our new class would be +Vector+.

In principle, we could define our new class from scratch, but it would
be a lot easier to use the features that the +Array+ class already has.
All we really want to do is to tame the +Array+ class to behave like
proper physical vectors, and we can do this by redefining only some of
the array operations, such as adding two arrays and multiplying an array
with a scalar.

In Ruby, just like in C++ and many other object-oriented languages, we
can do this by an approach called _inheritance_.  Instead of just defining
a new class

  class Vector

we can write

  class Vector < Array

which means that the new +Vector+ class inherits all the features of
the existing class +Array+.  The +Vector+ class is then called a
_subclass_ of the +Array+ class, and the +Array+ class is called a
_superclass_ of the +Vector+ class.

Okay, let me see whether I can redefine the array addition operator,
so that vectors can be added in the right way.  From what I've seen
so far, I guess that Ruby wants us to write something like this, in
file <tt>vector_try_addition1.rb</tt>:

 :inccode: .vector_try_addition1.rb

The class definition here contains only one method, by the name of
<tt>plus</tt>, that is doing the addition.

== Who is Adding What

*Erica*: That's a lot shorter and simpler than I had expected.
It seems to deliver all the three things you promised: it hides the
all <tt>[k]</tt> occurrences, it hides the <tt>each_index</tt>
and it creates a new vector, so that you don't have to declare
anything.  And all that in just a few lines!

*Dan*: Not so fast.  I'm not there yet.  In fact, I don't understand
this at all.  To begin with, shouldn't addition have two arguments?
You're going to add two vectors, no?

*Carol*: Yes, but here we're describing addition from the point of view
of a vector, an instance of the +Vector+ class.  Given one vector, all
we have to do is to specify one second vector, which I have called +a+,
which can then be added to the given vector.  The given vector itself
simply goes by the name of +self+, a reserved word that points to the
current instance of the class.

*Dan*: You mean that the class definition describes vectors in general,
but if I deal with a particular vector, <tt>v1</tt>, then from the point of
view of <tt>v1</tt> itself, <tt>v1</tt> is called +self+?

*Carol*: Right.

*Dan*: But we want to get the result <tt>v = v1 + v2</tt>.
So from the point of view of +v+ there really are two other vectors
involved.

*Carol*: Yes, but at first we only have <tt>v1</tt> and <tt>v2</tt>.
That's all we've got, and that's what we have to use to construct +a+.
The way I'm trying to define addition is by starting with one of the
two vectors <tt>v1</tt>, and to define a method that allows <tt>v1</tt>
to accept a second vector <tt>v2</tt>.  So the whole operation can then
be writen as

  v1.plus(v2)

where <tt>v2</tt> is the argument for the method +plus+ that is
associated with the class +Vector+ of which <tt>v1</tt> is an instance.
Now this expression will result a new instance of the +Vector+ class,
and we can assign that new instance to the new variable +v+ by writing:

  v = v1.plus(v2)

*Dan*: You can't write

  v = v1 plus v2

?

*Carol*: Sorry, no, you can't; that wouldn't make any sense.  What you
_can_ do in Ruby is leave out the parentheses around the argument of a
method.  So instead of writing

  v = v1.plus(v2)

you _can_ indeed write

  v = v1.plus v2

== The +plus+ Method

*Dan*: I'll take your word for it.  So if we write this, <tt>v1</tt>
uses its own +plus+ method, and according to the definition you wrote
in the +Vector+ class, <tt>v1</tt> first creates a new vector called
+sum+.  What does the new vector look like?  Is it just an empty array?

*Carol*: What else could it be?  But let's make sure:

 :commandinputoutputnoecho: irb END
require "vector_try_addition1.rb"
sum = Vector.new
quit
END

*Dan*: That looks like an empty array.

*Carol*: Yes, because the +Vector+ class inherits the +Array+ notation.

*Dan*: How can you see the difference?

*Carol*: You can't, unless you ask.  Here is how you ask:

 :commandinputoutputnoecho: irb END
require "vector_try_addition1.rb"
a = []
a.class
a = Vector.new
a.class
quit
END

Every object in Ruby has a built-in method +class+ that you can
use to ask it what class it is a member of.

*Dan*: So you first create an array, by writing <tt>[]</tt> and you
assign it to the variable +a+.  Then you create a vector by writing
<tt>Vector.new</tt>, and again you assign it to the same variable.
By doing so you override the previous content of that variable, and
not only that, you override the previous type of the content of that
variable: you've now changed both the content of +a+ and the type of +a+.

*Carol*: Yes.  That is exactly the dynamic typing property of Ruby, that
can you dynamically change the type in that way.  But when we deal with
Ruby, it is better to use the word class, rather than type.  The type of
a variable is the class to which the content of that variable belongs.

*Dan*: Now I'm beginning to see what you did when you wrote the
file <tt>vector_try_addition1.rb</tt>.  Let's look at it again:

 :inccode: .vector_try_addition1.rb

When I write

  v = v1.plus v2

<tt>v1</tt> creates a new vector called +sum+, and then it assigns the
the value <tt>sum[k] = v1[k]+v2[k]</tt> to each component <tt>[k]</tt>
of the vector +sum+.  That makes sense!

And finally, in the next line you return the value +sum+, before you
reach the end of the method.  In that way +v+ receives the value
that <tt>v1.plus v2</tt> returns, which is the sum of <tt>v1</tt> and
<tt>v2</tt>.  Okay, I got it now!

*Carol*: Let's hope it works, after everything I've told you!

 :commandinputoutputnoecho: irb END
require "vector_try_addition1.rb"
v1 = Vector[1, 2, 3]
v2 = Vector[5, 6, 7]
v = v1.plus v2
quit
END

*Dan*: Wonderful!  That's just what we ordered.

*Erica*: A great improvement over the old array addition!

== The <tt>+</tt> Method

*Dan*: Still, I can't say I like your new notation.
I'm still not happy about the asymmetry.  Writing

  v = v1.plus v2

gives the impression that <tt>v1</tt> is charging forwards, gobbling
up <tt>v2</tt> and then spitting out the result.  You told me that we
cannot write 

  v = v1 plus v2

and I understand that such a statement would have no clear meaning in
Ruby.  But is there really no way to make the expression more symmetric,
rather than making <tt>v1</tt> the predator and <tt>v2</tt> the prey?

*Carol*: Actually, there is a way to make it at least _look_ more symmetric.
It is just a form of syntactic sugar, as they call it: a way to let the
syntax look more tasty, without really changing the underlying code.

The idea is what is called `overloading operators'.  We can use the
<tt>+</tt> symbol, instead of the word +plus+, and we can define the
meaning of <tt>+</tt> for the case of vectors.  I read about that; let
me see whether it works.  I believe the idea is to write something like
this, in file <tt>vector_try_addition2.rb</tt>:

 :inccode: .vector_try_addition2.rb

*Dan*: All you've done is to change +plus+ into <tt>+</tt> in the second
line.  Can that really work?

*Erica*: There is one more change: you've also left out the word +return+
in the third line of the definition.

*Carol*: Ah yes, most people writing Ruby seem to leave out +return+;
it is really not necessary to add that.  You just have to remember to
let the last line of a definition echo the result you want to return.
The result of invoking a method is to return whatever the last line
of the definition evaluates to.

And yes, other than that, I've just replaced +plus+ by <tt>+</tt>.
In fact, in _all_ cases where Ruby uses <tt>+</tt>, it is only
syntactic sugar for invoking a method that is associated with the
left-hand side of the <tt>+</tt> symbol.  So even though it _looks_
symmetric, it never really has been a symmetric operation.

*Dan*: But how can it work?  I thought that you always needed to write
a dot between an object and its method.

*Carol*: Generally, that is true, and in fact, if you want to, you still
can write the <tt>+</tt> operator using a period like normal Ruby methods.

*Dan*: Let me try:

 :commandinputoutputnoecho: irb END
2.+ 3
8.* 4
quit
END

*Erica*: Wow, surprise.  They work just like ordinary Ruby methods.

*Dan*: Are you sure?  Isn't <tt>2.</tt> just translated into <tt>2.0</tt>
so that we are only evaluating <tt>2.0 + 3</tt>?  Let's check, by adding
a space after the periods:

 :commandinputoutputnoecho: irb END
2. + 3
8. * 4
quit
END

Ah, you see, the zero is just added, like in Fortran.

*Carol*: I don't think so.  Let me try a simpler case:

 :commandinputoutputnoecho: irb END
2.
quit
quit
END

You see: <tt>2.</tt> is _not_ translated into <tt>2.0</tt>, but is in fact
illegal.  Or more accurately, it is okay in Ruby to leave space after the
period between an object and its method.  Here +irb+ is asking for the
method name, and doesn't like the fact that I just wanted to quit; +irb+
interpreted the +quit+ as the method name it was waiting for.

*Dan*: I agree, we can now be sure that <tt>2.+</tt>
really invokes the addition operator of the number <tt>2</tt>.
Okay, now we know.

*Carol*: But of course, it is much more intuitively obvious to write
<tt>2 + 3</tt> than to write <tt>2.+ 3</tt>.  One of the main principles
that was used by Matsumoto, the designer of Ruby, was the principle of
least surprise.  Even though in fact Ruby has much in common with Lisp,
Matsumoto decided not to use a lisp like notation, in which <tt>2 + 3</tt>
would have looked something like <tt>(+ (2, 3))</tt>, a beautifully clear
notation once you get used to it, but unlike <tt>2 + 3</tt> not immediately
obvious at first.

Well, enough talk: let's test my second version of vector addition:

 :commandinputoutputnoecho: irb END
require "vector_try_addition2.rb"
v1 = Vector[1, 2, 3]
v2 = Vector[5, 6, 7]
v = v1 + v2
quit
END

*Dan*: I like this a whole lot better!  And I'm glad Matsumoto did not
introduce four parentheses to add two things.
