= Writing the Code

== Choosing an Algorithm

*Carol*:
Now that we have the equations of motion for the relative position of
one particle with respect to the other, I guess we need an algorithm
to integrate these equations.

*Erica*:
Indeed, and there is a large choice!  If you pick up any book on
numerical methods, you will see that you can select from a variety of
lower-order and higher-order integrators, and for each one there are
additional choices as to the precise structure of the algorithm.

*Dan*:
What is the order of an algorithm?

*Erica*:
It signifies the rate of convergence.  Since no algorithm with a
finite time step size is perfect, they all make numerical errors.
In a fourth-order algorithm, for example, this error scales as the
fourth power of the time step -- hence the name fourth order.

*Carol*:
If that is the case, why not take a tenth order or even a twentieth
order algorithm.  By only slightly reducing the time step, we would
read machine accuracy, of order <tex>$10^{-15}$</tex> for the usual double
precision (8 byte, i.e. 64 bit) representation of floating point numbers.

*Erica*:
The drawback of using high-order integrators is two-fold: first, they
are far more complex to code; and secondly, they do not allow arbitrarily
large time steps, since their region of convergence is limited.  As a
consequence, there is an optimal order for each type of problem.  When
you want to integrate a relatively well-behaved system, such as the
motion of the planets in the solar system, a twelfth-order integrator
may well be optimal.  Since all planets follow well-separated orbits,
there will be no sudden surprises there.  But when you integrate a
star cluster, where some of the stars can come arbitrarily close to each
other, experience shows that very high order integrators lose their edge.
In practice, fourth-order integrators have been used most often for the job.

*Dan*:
How about starting with the lowest-order integrator we can think of?
A zeroth-order integrator would make no sense, since the error would
remain constant, independent of the time step size.  So the simplest
one must be a first-order integrator.

*Erica*:
Indeed.  And the simplest version of a first-order integrator is
called the <i>forward Euler</i> integrator.

*Dan*:
Was Euler so forward-looking, or is there also a <i>backward Euler</i>
algorithm?

*Erica*:
There is indeed.  In the forward version, at each time step you simply
take a step tangential to the orbit you are on.  After that, at the
next step, the new value of the acceleration forces you to slightly
change direction, and again you move for a time step <tex>$dt$</tex>
in a straight line in that direction.  Your approximate orbit is thus
constructed out of a number of straight line segments, where each one
has the proper direction at the beginning of the segment, but the
wrong one at the end.

:figure: forward1.eps 6cm forward1
The forward Euler approximation is indicated by the straight arrows,
while the curved lines show the true solution to a differential equation.

*Dan*:
And the <i>backward Euler</i> algorithm must have the right direction
at the end of a time step, and the wrong one at the beginning.  Let's
see.  That seems much harder to construct.  How do you know at the
beginning of a time step in what direction to move so that you come
out with the right direction tangential to a correct orbit at that
point?

:figure: backward1.eps 6cm backward1
As figure ref(forward1), but now for the backward Euler approximation.

*Erica*:
You do that through iteration.  You guess a direction, and
then you correct for the mistake you find yourself making, so that
your second iteration is much more accurate, in fact first-order
accurate.  Given this extra complexity, I suggest that we start with
the forward Euler algorithm.

*Carol*:
Can't we do both, _ie_ make half the mistakes of each of the two, while
trying to strike the right balance between forward and backward Euler?

*Erica*:
Aha!  That is a good way to construct better algorithms, which then
become second-order accurate, because you have canceled the first-order
errors.  Examples are second-order Runge Kutta, and leapfrog.  We'll
soon come to that, but for now let's keep it simple, and stay with
first order.  Here is the mathematical notation:

:eqnarray:
\label{ForwardEulerStep}
\br_{i+1} & = & \br_i + \bv_i dt    \nonumber \\
\bv_{i+1} & = & \bv_i + \ba_i dt

for the position <tex>$\br$</tex> and velocity <tex>$\bv$</tex> of an individual particle,
where the index <tex>$i$</tex> indicates the values for time <tex>$t_i$</tex> and <tex>$i+1$</tex> for
the time <tex>$t_{i+1}$</tex> after one more time step has been taken:
<tex>$dt = t_{i+1} - t_i$</tex>.  The acceleration induced on a particle by the
gravitational forces of all other particles is indicated by <tex>$\ba$</tex>.
So, all we have to do now is to code it up.  By the way, let's rename
the file.  Rather than a generic name <tt>nbody.rb</tt>, let's call it
<tt>euler.rb</tt>.

*Dan*:
Erica, go for it!

== Specifying Initial Conditions

*Carol*: In order to solve a differential equation, you have to provide
initial conditions.

*Erica*: 
You mean we have to start by specifying the initial separation between
the particles.  How about a simple choice like this?

 :inccode: .euler.rb-1

*Dan*: Let me put this into words.  The relative position vector is
chosen along the <tex>$x$</tex> axis at a distance of unity from the
origin where the other particle resides in the relative coordinate
system that we use: <tex>$\br = \{1, 0, 0\}$</tex>.  The relative
velocity is chosen to be <tex>$0.5$</tex> in the direction of the
positive <tex>$y$</tex> axis: <tex>$\bv = \{0, 0.5, 0\}$</tex>.
This means that the initial motion is at right angles to initial separation.

*Carol*: Does this mean that the two particles will move around each other
in a circle?

*Erica*: Probably not, unless we give exactly the right velocity
needed for circular motion.  In general, the orbit will take the shape
of an ellipse, if the two particles are bound.  If the initial speed
is too high, the particles escape from each other, in a parabolic or
hyperbolic orbit.

*Dan*: Starting from the initial conditions, we have to step forward in time.
I have no idea how large the time step step +dt+ should be.

*Carol*: But at least we can argue that it should not be too large.
The distance +dr+ over which the particles travel during a time step
+dt+ must be very small compared to the separation between the two
particles:

:equation:
dr = v\ dt \ll r

With <tex>$v=1$</tex> and <tex>$r=1$</tex>, this means
<tex>$dt\ll 1$</tex>.

*Dan*: In that case, we could take `much less than 1' to mean 0.1,
for starters.

*Carol*: I would prefer an even smaller value.  Looking at fig. (ref(forward1))
we see how quickly the forward Euler scheme flies off the tracks, so to speak.
How about letting `much less than 1' be 0.01?  We can always make the step
larger, if it turns out to be unnecessarily small.  Here, let me add
this to the code:

 :inccode: .euler.rb-2

== Looping in Ruby

*Erica*: We now know where we start in space, and with what velocity.
We also know the size of each time step.  All we have to do is start
taking steps.

*Dan*: With a tiny time step of <tex>$dt = 0.01$</tex>, we'll have to take
at least a hundred steps to see much happening, I guess.  And to go a bit
further, say from time <tex>$t = 0$</tex> to time <tex>$t = 10$</tex>, we
will need a thousand steps.

*Erica*: That means we have to construct a loop.  Something like `for
<tex>$i=1$</tex> till <tex>$i=1000$</tex> do something.'  At least that
is how most computer languages express it.  I wonder how ruby does it.

*Carol*: Let's have a look at the Ruby book.  How do you repeat the same
thing +k+ times?  Ah, here it is.  That looks funny!  You write
<tt>k.times</tt>!  So to traverse a piece of code <tex>$1000$</tex> times,
you enclose that piece of code within the following loop wrapper:

 :inccode: .euler.rb-3

*Dan*: Surely you are joking!  That is carrying the principle of least
surprise a bit too far to believe.  How can that work?  Can a computer
language really stay so close to English?

*Carol*: The key seems to be that Ruby is an object-oriented language.
Each `thing' is ruby is an object, which can have attributes such as
perhaps internal data or internal methods, which may or may not be
visible from the outside.

*Erica*: I have heard the term `object-oriented programming.'  I really
should browse through the Ruby book, to get a bit more familiar with that
approach.

*Dan*: We all should.  But for now, Carol, how does your key work?
Is the number <tex>$1000$</tex> also an object?

*Carol*: You guessed it!  And every number has by default various methods
associated with it.  One method happens to be called +times+.

*Erica*: And what +times+ does is repeat the content of its argument,
whatever is within the curly brackets, +k+ times, if the number is +k+.

*Carol*: Precisely.  A bunch of expressions between curly brackets is
called a block in Ruby, and this block is executed +k+ times.  We will
have to get used to the main concepts of Ruby as we go along, but if
you want to read about Ruby in more systematic way, here is a
<web>http://www.rubycentral.com/|a good place to start</web>, and here
is a web site specifically aimed at
<web>http://sciruby.codeforpeople.com/|scientific applications</web>.

== Interactive Ruby: +irb+

*Dan*: Amazing.  Well, I would be even more amazed to see this work.

*Carol*: Let's test it out, using +irb+.  This is an interactive program
that allows you to test little snippets of Ruby code.  Let us explore what
it can do for us.  You can invoke it simply by type its name:

    |gravity> irb
    irb(main):001:0>

It seems that we can now type any Ruby expression, which will then be
evaluated right away.  Let me try something simple:

    irb(main):001:0> 2 + 3
    => 5
    irb(main):002:0>

*Erica*: How about going from arithmetic to algebra, by using some variables?
Can I try?

    irb(main):002:0> a = 4
    => 4
    irb(main):003:0> b = 5
    => 5
    irb(main):004:0> c = a * b
    => 20
    irb(main):005:0> 

I see.  At the end of each line, the result of the operation is echoed.

*Dan*: But has the value 20 been correctly assigned to the variable +c+?
Let me take me turn:

    irb(main):005:0> c
    => 20
    irb(main):006:0> 

Good.  Always best to test, to make sure.

*Carol*: Indeed.  Time to test Ruby's looping construct:

    irb(main):006:0> 3.times{ c += 1 }
    => 3
    irb(main):007:0> c
    => 23
    irb(main):008:0> 

Perfect!  We started with 20 and three times we added 1.

*Dan*: ah, so <tt>c += 1</tt> is the same as <tt>c = c + 1</tt>?

*Carol*: Yes.  This is a construction used in C, and since taken over
by various other languages.  It applies for many operators, not only
addition.  For example, <tt>c *= d</tt> is the same as <tt>c = c * d</tt>.

*Erica*: How do we leave +irb+?

*Carol*: By typing +quit+:

    irb(main):008:0> quit
    |gravity>

== One Step at a Time

*Dan*: All that is left for us to do is to write the content of the loop.
That means we have to describe how to take a single step forward in time.

*Erica*: Specifically, at the start we have to tell the particles how
to move to their next relative position, from our starting point of time
<tex>$t=0$</tex> to <tex>$t=0.01$</tex>, in our case.  Or for a
general +dt+ value, using the forward Euler approximation
(ref(ForwardEulerStep)), we obtain the position
<tex>$\br = \{r_x, r_y, r_z\}$</tex> at the end of the first step:

 :inccode: .euler.rb-4

In addition, we have to tell the particles what their new relative velocity
<tex>$\bv = \{v_x, v_y, v_z\}$</tex>
should be.  Using the same forward Euler construction, we can write:

 :inccode: .euler.rb-5

using the acceleration vector <tex>$\ba = \{a_x, a_y, a_z\}$</tex>.

*Dan*: But we haven't calculated the acceleration +a+ yet!

*Carol*: This is an important example of code writing, something called
`wishful thinking' or `wishful programming'.  You start writing a code
as if you already have the main ingredients in hand, and then you go
back and fill in the commands needed to compute those ingredients.

*Dan*: That sounds like a top-down programming approach, which makes sense:
I like to start with an overview of what needs to be done.  It is all too
easy to start from the bottom up, only to get lost while trying to put all
the pieces together.

*Erica*: To compute the acceleration, we have to solve the differential
equation for the Newtonian two-body problem, Eq. (ref(Newton2bodysimple)).
I will copy it here again:

:equation:
\ba = - \frac{\br}{r^3}

*Dan*: Can you write it out in component notation?

*Erica*: Sure:

:eqnarray:
a_x &=& - \frac{x}{r^3}    \nonumber \\
a_y &=& - \frac{y}{r^3}    \nonumber \\
a_z &=& - \frac{z}{r^3}

where the magnitude of the separation <tex>$r$</tex> is defined as

:equation:
r = \sqrt{x^2 + y^2 + z^2}

Let me start with the last line:

 :inccode: .euler.rb-6

*Carol*: Let's see whether I remember my vector analysis class.  The quantity
<tex>$\br$</tex> is called a vector, and the quantity <tex>$r$</tex> is called
a scalar, right?

*Erica*: Indeed.  The last quantity is a scalar because it is independent of
your choice of coordinate system.  If we rotate out coordinates, the values
of <tex>$x$</tex> and of <tex>$y$</tex> and of <tex>$z$</tex> may all change,
and therefore <tex>$\br$</tex> will change.  However, <tex>$r$</tex> will
stay the same, and that is a good thing: it denotes the physical distance
between the particles, something that you can measure.  When two people use
two different coordinate systems, and both measure <tex>$r$</tex>, the value
they find had better be the same.

*Dan*: My Ruby book tells me that you must add the line

 :inccode: .euler.rb-7

in order to use the square root method +sqrt+, where the term method
is used in the same way the word function is used in C and the word
subroutine is used in Fortran.  The <tt>include</tt> statement is
needed in order to gain access to the +Math+ module in Ruby, where
many of the mathematical methods reside.

*Erica*: Thanks!  Now the rest is straightforward:

 :inccode: .euler.rb-8

== Printing the Result

*Dan*: Shall we see whether the program works, so far?  Let's run it!

*Carol*: Small point, but . . . perhaps we should add a print statement,
to get the result on the screen?

*Erica*: I guess that doesn't hurt!  The Ruby syntax for printing seems to be
very intuitive, following what they call the `principle of least surprise':

 :inccode: .euler.rb-9

*Carol*: I like that principle!  And indeed, this couldn't be simpler!

*Dan*: Apart from this mysterious <tt>\n</tt> at the end.  What does that do?

*Carol*: It prints a new line.  This notation is borrowed from the C language.
By the way, I'd like to see a printout of the position and velocity at the
start of the run as well, before we enter the loop, so that we get all the
points, from start to finish.

*Erica*: Fine!  Here it is, our first program, <tt>euler.rb</tt>, which
is supposed to evolve our two-body problem for ten time units, from
<tt>t = 0</tt> till <tt>t = 10</tt>:

 :inccode: .euler.rb

