= xxx

== Verification & Validation

*Carol*: Yes, it looks reasonable.  But how do we know it really is
reasonable?

*Dan*: We can even check everything by hand.  Since we have initially

:equation:
\br(0) = \{x, y, z\} = \{1,0,0\}

and

:equation:
\bv(0) = \{v_x, v_y, v_z\} = \{0,1,0\}

the new position must be:

:equation:
\br(dt) = \br + \bv dt = \{1,dt,0\}

*Carol*: And this is indeed what we see in the first half of the last output
line.

*Dan*: To compute the new velocity, we have to first compute the
acceleration vector.  Let's see, Newton's equation of motion for the
two-body problem, as written above in component form, gives simply:

:equation:
\ba = \{a_x, a_y, a_z\} = \{-1,0,0\}

This means that

:equation:
\bv(dt) = \bv + \ba dt = \{-dt,1,0\}

*Erica*: And this is indeed what is printed in the last half of the last
output line.

*Dan*: Perfect!

*Carol*: Well, sort-of.  We have verified that our program does what the
algorithm intended, and that is certainly nice!  But this is only half
of the work.  We now have to check whether this particular algorithm
does indeed give a reasonable result, which corresponds to the behavior
of gravitating particles in the real world.  This is called validation.
In the computer science literature these two checks are often called 
V&V, for Verification and Validation.

In other words, we have passed the verification test, so now we have
to do a validation test.  For example, we can ask whether this first
step keeps the two particles on a circular orbit.  After the first
step, the new separation is:

:equation:
r(0.1) = \sqrt{x^2 + y^2 + z^2} = \sqrt{1 + 0.1^2} = \sqrt{1.01} \approx 1.005

*Dan*: Instead of the correct value of <tex>$r(0.1)=1$</tex>, we are half a
percent off.  Not bad, I would say.

*Carol*: Not bad for one step, perhaps, but our orbit has a radius of unity,
which means a circumference of <tex>$2\pi \approx 6.3$</tex>.  With a velocity
of unity, it will take <tex>$63$</tex> steps to go around the circle,
at the rate we are going.  And if every step introduces `only' half a percent
error, and if the errors built up linearly, we wind up with a total error of
more than 30%, even during the first revolution!

*Dan*: Good point.  Of course, we don't know whether the errors build up
linearly, but for lack of a better idea, that would be the first guess.
Perhaps we should take a smaller time step.  What would happen if we would
use <tex>$dt = 0.01$</tex>?  Let's repeat your analysis.  After one step,
we would have

:equation:
r(0.01) = \sqrt{x^2 + y^2 + z^2} = \sqrt{1 + 0.01^2} = \sqrt{1.0001}
\approx 1.00005

We now need roughly <tex>$630$</tex> steps to go around the circle,
If the errors build up linearly, the radial separation will grow to
something like <tex>$1 + 630*0.00005 \approx 1.03$</tex>.  Aha!  Only
a 3% error, instead of roughly 30%.

*Erica*: Bravo!  You have just proved that the forward Euler scheme is
a first-order scheme!  Remember our discussion at the start?  For a
first-order scheme, the errors scales like the first power of the time
step.  You just showed that taking a time step that is ten times smaller
leads to a ten times smaller error after completing one revolution.

*Dan*: Great!  I thought that numerical analysis was a lot harder.

*Carol*: Believe me, it _is_ a lot harder for any numerical integration
scheme that is more complex than first-order.  You'll see!

*Dan*: I can wait.  For now I'm happy to work with a scheme which I can
completely understand.  On to the next step!  And ah, yes, let us take
steps with a size <tex>$dt = 0.01$</tex>, given what we've just learned.

== A Simple Loop

*Erica*: We'd better introduce a loop, since we'll need to take a lot of
steps.  At the very least we want to move around the circle once, which
would take a bit more than six time units.  Let's make it ten time units,
for good measure.  With a step size of <tex>$dt = 0.01$</tex>, we'll have
to take <tex>$1000$</tex> steps to reach <tex>$t = 10$</tex>.

*Carol*: Let's have a look at the Ruby book.  How do you repeat the same
thing +k+ times?  Ah, here it is.  That looks funny!  You write
<tt>k.times</tt>!  So to traverse a piece of code <tex>$1000$</tex> times,
you enclose that piece of code within the following loop wrapper:

 :inccode: .euler_circular_bug.rb-1

*Dan*: Surely you are joking!  That is carrying the principle of least
surprise a bit too far to believe.  How can that work?  Can a computer
language really stay so close to English?

*Carol*: The key seems to be that Ruby is an object-oriented language.
Each `thing' is ruby is an object, which can have attributes such as
perhaps internal data or internal methods, which may or may not be
visible from the outside.

*Erica*: I have heard the term `object-oriented programming.'  I really
should browse through the Ruby book, to get a bit more familiar with that
approach.

*Dan*: We all should.  But for now, Carol, how does your key work?
Is the number <tex>$1000$</tex> also an object?

*Carol*: You guessed it!  And every number has by default various methods
associated with it.  One method happens to be called +times+.

*Erica*: And what +times+ does is repeat the contant of its argument,
whatever is within the curly brackets, +k+ times, if the number is +k+.

*Carol*: Precisely.

*Dan*: Amazing.  Well, I would be even more amazed to see this work.

*Erica*: Why shouldn't it work?  Let's try it!  Telling the computer how
to take the first step was hard, but letting it take another 999 steps
should be easy, given this natural looping construct.  Here is the new
version of the code:

 :inccode: .euler_circular_bug.rb

== A Surprise

*Carol*: I don't think you would like to read through 1001 lines of output.
Let's run the code while redirecting the output to a file <tt>euler.our</tt>.

 :command: cp euler_circular_bug.rb euler.rb
 :commandoutput: ruby euler.rb > euler.out

We can then have a peek at, say, the first five lines and the last
five lines, while skipping the 991 lines in between:

 :commandoutput: head -5 euler.out
 :commandoutput: tail -5 euler.out

*Dan*: Instead of a bunch of numbers, I'd rather see a plot of the orbit.

*Erica*: I agree, we should do that soon.  But hey, the numbers do tell us
something already, namely that there is something seriously wrong!

*Carol*: Right you are, the numbers are much too large.  We are trying
to let two particles move around a circle, at a relative distance of 1.
However, here the separation in the <tex>$y$</tex> direction alone is
already larger than <tex>$11$</tex>, so the total separation must be
even larger.  I did not expect such a large error.

*Dan*: Hmmm, yes, that is rather surprising.  And yet, look, the result
of the very first step is exactly correct.  It is just what we would
expect, when scaling our earlier result, from a time step of
<tex>$dt=0.1$</tex> to a time step of <tex>$dt=0.01$</tex>.

*Erica*: Well, let us look at the orbit.  How do we make a plot?

*Carol*: I suggest using <tt>gnuplot</tt>, present on any Linux
running system, and something that can be easily installed on many
other systems as well.  The style is not particularly pretty, but at
least it will give us something to look at.

*Dan*: How do you invoke <tt>gnuplot</tt>?

*Carol*: To use it is quite simple, with only one command
needed to plot a graph.  In our case, however, I'll start with the
command <tt>set size ratio -1</tt>.  A positive value for the size
ratio scales the aspect ratio of the vertical and horizontal edge of
the box in which a figure appears.  But in our case we want to
set the scales so that the unit has the same length on both the x and
y axes.  Gnuplot can be instructed to do so by specifying the ratio to
be <tt>-1</tt>.  In fact, let me write the line <tt>set size ratio
-1</tt> in a file called <tt>.gnuplot</tt> in my home directory.  That
way we don't have to type it each time we use gnuplot.  Okay, done.
Now let's have our picture:

xxxxxxxxx

Let's plot it (fig ref(euler_circular_bug) ):

 gnuplot
 set size ratio -1
 plot "euler.out"
 quit

 :commandinput: gnuplot END
set term post eps
set output "euler_circular_bug.ps"
set size ratio -1
plot "euler.out"
quit
END

 :figure: euler_circular_bug.ps 10cm euler_circular_bug
 First attempt at integrating the two-body problem: failure.

== Debugging

xxxxx

== Much Better

Corrected code <tt>euler_circular.rb</tt>, but we show it as if it is called
<tt>euler.rb</tt>:

 :inccode: .euler_circular.rb

Let's run it:

 :command: cp euler_circular.rb euler.rb
 :commandoutput: ruby euler.rb > euler.out
 :commandoutput: head -5 euler.out
 :commandoutput: tail -5 euler.out

Let's plot it:

 :commandinput: gnuplot END
set term post eps
set output "euler_circular.ps"
set size ratio -1
plot "euler.out"
quit
END

 :figure: euler_circular.ps 10cm euler_circular
 Second attempt at integrating the two-body problem: looking a lot better.

