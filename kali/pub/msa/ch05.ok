= Writing the Code

== Choosing a Computer Language

*Carol*:
Let's start coding!  Which language shall we use to write a computer code?
I bet you physics types insist on using Fortran.

*Erica*:
Believe it or not, most of the code to be overhauled has been written
in C++, and I suggest that we adopt the same language.  It may not be
exactly my favorite, but it is at least widely available, well
supported, and likely to stay with us for decades.

*Dan*:
What is C++, and why the obscure name?  Makes the notion of an N-body
problem seem like clarity itself!

*Carol*:
Long story.  I don't know whether there was ever a language A, but
there certainly was a language B, which was followed alphabetically by
a newer language C, which became quite popular . . .

*Dan*:
. . . are you making a pun on our names?

*Carol*:
No, I'm not kidding.  Then C was extended to a new language for
object-oriented programming, something we'll talk about later.  In a
nerdy pun, the increment operation ``++'' from the C language was used
to indicate that C++ was the successor language to C.  Don't look at
me, we'll have to live with it.

*Dan*:
But everybody I know seems to be coding in Java.

*Carol*:
Java has a clear advantage over C++ in being almost platform independent,
but frankly, I don't like either C++ or Java.  Recently, I took a
course in which the instructor used a scripting language, Ruby was the
name.  And I was surprised at the flexible way in which you could
quickly express rather complex ideas in that language.

*Erica*:
Does Ruby have something like STL?

*Carol*:
You mean the Standard Template Library in C++?  Ruby doesn't need any
of those complications because it is already dynamically typed from
the start!

*Dan*:
I have no idea what the two of you are talking about, but I agree with
Carol, let's start coding, in whatever language!

== Choosing an Algorithm

*Carol*:
We want to write a simulation code, to enable us to simulate the
behavior of stars that move under the influence of gravity.  So
far we have derived the equations of motion for the relative position
of one particle with respect to the other.  What we need now is an
algorithm to integrate these equations.

*Dan*: What does it mean to integrate an equation?

*Carol*: We are dealing with differential equations.  In calculus,
differentation is the opposite of integration.  If you differentiate
an expression, and then integrate it again, you get the same expression
back, apart from a constant.  Our differential equations describe the
time derivatives of position and velocity.  In order to obtain the
actual values for the position and velocity as a function of time, we
have to integrate the differential equation.

*Erica*:
And to do so, we need an integration algorithm.  And yes,
there is a large choice!  If you pick up any book on
numerical methods, you will see that you can select from a variety of
lower-order and higher-order integrators, and for each one there are
additional choices as to the precise structure of the algorithm.

*Dan*:
What is the order of an algorithm?

*Erica*:
It signifies the rate of convergence.  Since no algorithm with a
finite time step size is perfect, they all make numerical errors.
In a fourth-order algorithm, for example, this error scales as the
fourth power of the time step -- hence the name fourth order.

*Carol*:
If that is the case, why not take a tenth order or even a twentieth
order algorithm.  By only slightly reducing the time step, we would
read machine accuracy, of order <tex>$10^{-15}$</tex> for the usual double
precision (8 byte, i.e. 64 bit) representation of floating point numbers.

*Erica*:
The drawback of using high-order integrators is two-fold: first, they
are far more complex to code; and secondly, they do not allow arbitrarily
large time steps, since their region of convergence is limited.  As a
consequence, there is an optimal order for each type of problem.  When
you want to integrate a relatively well-behaved system, such as the
motion of the planets in the solar system, a twelfth-order integrator
may well be optimal.  Since all planets follow well-separated orbits,
there will be no sudden surprises there.  But when you integrate a
star cluster, where some of the stars can come arbitrarily close to each
other, experience shows that very high order integrators lose their edge.
In practice, fourth-order integrators have been used most often for the job.

*Dan*:
How about starting with the lowest-order integrator we can think of?
A zeroth-order integrator would make no sense, since the error would
remain constant, independent of the time step size.  So the simplest
one must be a first-order integrator.

*Erica*:
Indeed.  And the simplest version of a first-order integrator is
called the <i>forward Euler</i> integrator.

*Dan*:
Was Euler so forward-looking, or is there also a <i>backward Euler</i>
algorithm?

*Erica*:
There is indeed.  In the forward version, at each time step you simply
take a step tangential to the orbit you are on.  After that, at the
next step, the new value of the acceleration forces you to slightly
change direction, and again you move for a time step <tex>$dt$</tex>
in a straight line in that direction.  Your approximate orbit is thus
constructed out of a number of straight line segments, where each one
has the proper direction at the beginning of the segment, but the
wrong one at the end.

:figure: forward1.eps 6cm forward1
The forward Euler approximation is indicated by the straight arrows,
while the curved lines show the true solutions to the differential equation.

*Dan*:
And the <i>backward Euler</i> algorithm must have the right direction
at the end of a time step, and the wrong one at the beginning.  Let's
see.  That seems much harder to construct.  How do you know at the
beginning of a time step in what direction to move so that you come
out with the right direction tangential to a correct orbit at that
point?

:figure: backward1.eps 6cm backward1
As figure ref(forward1), but now for the backward Euler approximation.

*Erica*:
You do that through iteration.  You guess a direction, and
then you correct for the mistake you find yourself making, so that
your second iteration is much more accurate, in fact first-order
accurate.  Given this extra complexity, I suggest that we start with
the forward Euler algorithm.

*Carol*:
Can't we do both, _ie_ make half the mistakes of each of the two, while
trying to strike the right balance between forward and backward Euler?

*Erica*:
Aha!  That is a good way to construct better algorithms, which then
become second-order accurate, because you have canceled the first-order
errors.  Examples are second-order Runge Kutta, and leapfrog.  We'll
soon come to that, but for now let's keep it simple, and stay with
first order.  Here is the mathematical notation:

:eqnarray:
\label{ForwardEulerStep}
\br_{i+1} & = & \br_i + \bv_i dt    \nonumber \\
\bv_{i+1} & = & \bv_i + \ba_i dt

for the position <tex>$\br$</tex> and velocity <tex>$\bv$</tex> of an individual particle,
where the index <tex>$i$</tex> indicates the values for time <tex>$t_i$</tex> and <tex>$i+1$</tex> for
the time <tex>$t_{i+1}$</tex> after one more time step has been taken:
<tex>$dt = t_{i+1} - t_i$</tex>.  The acceleration induced on a particle by the
gravitational forces of all other particles is indicated by <tex>$\ba$</tex>.
So, all we have to do now is to code it up.  By the way, let's rename
the file.  Rather than a generic name <tt>nbody.rb</tt>, let's call it
<tt>euler.rb</tt>.

*Dan*:
Erica, go for it!

== Specifying Initial Conditions

*Carol*: In order to solve a differential equation, you have to provide
initial conditions.

*Erica*: 
You mean we have to start by specifying the initial separation between
the particles.  How about a simple choice like this?

 :inccode: .euler.rb-1

*Dan*: Let me put this into words.  The relative position vector is
chosen along the <tex>$x$</tex> axis at a distance of unity from the
origin where the other particle resides in the relative coordinate
system that we use: <tex>$\br = \{1, 0, 0\}$</tex>.  The relative
velocity is chosen to be <tex>$0.5$</tex> in the direction of the
positive <tex>$y$</tex> axis: <tex>$\bv = \{0, 0.5, 0\}$</tex>.
This means that the initial motion is at right angles to initial separation.

*Carol*: Does this mean that the two particles will move around each other
in a circle?

*Erica*: Probably not, unless we give exactly the right velocity
needed for circular motion.  In general, the orbit will take the shape
of an ellipse, if the two particles are bound.  If the initial speed
is too high, the particles escape from each other, in a parabolic or
hyperbolic orbit.

*Dan*: Starting from the initial conditions, we have to step forward in time.
I have no idea how large the time step step +dt+ should be.

*Carol*: But at least we can argue that it should not be too large.
The distance +dr+ over which the particles travel during a time step
+dt+ must be very small compared to the separation between the two
particles:

:equation:
dr = v\ dt \ll r

With <tex>$v=1$</tex> and <tex>$r=1$</tex>, this means
<tex>$dt\ll 1$</tex>.

*Dan*: In that case, we could take `much less than 1' to mean 0.1,
for starters.

*Carol*: I would prefer an even smaller value.  Looking at fig. (ref(forward1))
we see how quickly the forward Euler scheme flies off the tracks, so to speak.
How about letting `much less than 1' be 0.01?  We can always make the step
larger, if it turns out to be unnecessarily small.  Here, let me add
this to the code:

 :inccode: .euler.rb-2

== Looping in Ruby

*Erica*: We now know where we start in space, and with what velocity.
We also know the size of each time step.  All we have to do is start
taking steps.

*Dan*: With a tiny time step of <tex>$dt = 0.01$</tex>, we'll have to take
at least a hundred steps to see much happening, I guess.  And to go a bit
further, say from time <tex>$t = 0$</tex> to time <tex>$t = 10$</tex>, we
will need a thousand steps.

*Erica*: That means we have to construct a loop.  Something like `for
<tex>$i=1$</tex> till <tex>$i=1000$</tex> do something.'  At least that
is how most computer languages express it.  I wonder how ruby does it.

*Carol*: Let's have a look at the Ruby book.  How do you repeat the same
thing +k+ times?  Ah, here it is.  That looks funny!  You write
<tt>k.times</tt>!  So to traverse a piece of code <tex>$1000$</tex> times,
you enclose that piece of code within the following loop wrapper:

 :inccode: .euler.rb-3

*Dan*: Surely you are joking!  That is carrying the principle of least
surprise a bit too far to believe.  How can that work?  Can a computer
language really stay so close to English?

*Carol*: The key seems to be that Ruby is an object-oriented language.
Each `thing' is ruby is an object, which can have attributes such as
perhaps internal data or internal methods, which may or may not be
visible from the outside.

*Erica*: I have heard the term `object-oriented programming.'  I really
should browse through the Ruby book, to get a bit more familiar with that
approach.

*Dan*: We all should.  But for now, Carol, how does your key work?
Is the number <tex>$1000$</tex> also an object?

*Carol*: You guessed it!  And every number has by default various methods
associated with it.  One method happens to be called +times+.

*Erica*: And what +times+ does is repeat the content of its argument,
whatever is within the curly brackets, +k+ times, if the number is +k+.

*Carol*: Precisely.  A bunch of expressions between curly brackets is
called a block in Ruby, and this block is executed +k+ times.  We will
have to get used to the main concepts of Ruby as we go along, but if
you want to read about Ruby in more systematic way, here is a
<web>http://www.rubycentral.com/|a good place to start</web>, and here
is a web site specifically aimed at
<web>http://sciruby.codeforpeople.com/|scientific applications</web>.

== Interactive Ruby: +irb+

*Dan*: Amazing.  Well, I would be even more amazed to see this work.

*Carol*: Let's test it out, using +irb+.  This is an interactive program
that allows you to test little snippets of Ruby code.  Let us explore what
it can do for us.  You can invoke it simply by type its name:

    |gravity> irb
    irb(main):001:0>

*Dan*: I like your prompt!

*Carol*: Well, I called my computer `gravity', and I set up my shell
to echo the name of my computer, so that's why it shows up here.

*Dan*: Quite appropriate.  Now how do we interact with +irb+?

It seems that we can now type any Ruby expression, which will then be
evaluated right away.  Let me try something simple:

    irb(main):001:0> 2 + 3
    => 5
    irb(main):002:0>

*Erica*: How about going from arithmetic to algebra, by using some variables?
Can I try?

    irb(main):002:0> a = 4
    => 4
    irb(main):003:0> b = 5
    => 5
    irb(main):004:0> c = a * b
    => 20
    irb(main):005:0> 

I see.  At the end of each line, the result of the operation is echoed.

*Dan*: But has the value 20 been correctly assigned to the variable +c+?
Let me take me turn:

    irb(main):005:0> c
    => 20
    irb(main):006:0> 

Good.  Always best to test, to make sure.

*Carol*: Indeed.  Time to test Ruby's looping construct:

    irb(main):006:0> 3.times{ c += 1 }
    => 3
    irb(main):007:0> c
    => 23
    irb(main):008:0> 

Perfect!  We started with 20 and three times we added 1.

*Dan*: ah, so <tt>c += 1</tt> is the same as <tt>c = c + 1</tt>?

*Carol*: Yes.  This is a construction used in C, and since taken over
by various other languages.  It applies for many operators, not only
addition.  For example, <tt>c *= d</tt> is the same as <tt>c = c * d</tt>.

*Erica*: How do we leave +irb+?

*Carol*: By typing +quit+:

    irb(main):008:0> quit
    |gravity>

== One Step at a Time

*Dan*: All that is left for us to do is to write the content of the loop.
That means we have to describe how to take a single step forward in time.

*Erica*: Specifically, at the start we have to tell the particles how
to move to their next relative position, from our starting point of time
<tex>$t=0$</tex> to <tex>$t=0.01$</tex>, in our case.  Or for a
general +dt+ value, using the forward Euler approximation
(ref(ForwardEulerStep)), we obtain the position
<tex>$\br = \{r_x, r_y, r_z\}$</tex> at the end of the first step:

 :inccode: .euler.rb-4

In addition, we have to tell the particles what their new relative velocity
<tex>$\bv = \{v_x, v_y, v_z\}$</tex>
should be.  Using the same forward Euler construction, we can write:

 :inccode: .euler.rb-5

using the acceleration vector <tex>$\ba = \{a_x, a_y, a_z\}$</tex>.

*Dan*: But we haven't calculated the acceleration +a+ yet!

*Carol*: This is an important example of code writing, something called
`wishful thinking' or `wishful programming'.  You start writing a code
as if you already have the main ingredients in hand, and then you go
back and fill in the commands needed to compute those ingredients.

*Dan*: That sounds like a top-down programming approach, which makes sense:
I like to start with an overview of what needs to be done.  It is all too
easy to start from the bottom up, only to get lost while trying to put all
the pieces together.

*Erica*: To compute the acceleration, we have to solve the differential
equation for the Newtonian two-body problem, Eq. (ref(Newton2bodysimple)).
I will copy it here again:

:equation:
\ba = - \frac{\br}{r^3}

*Dan*: Can you write it out in component notation?

*Erica*: Sure:

:eqnarray:
\label{axayaz}
a_x &=& - \frac{x}{r^3}    \nonumber \\
a_y &=& - \frac{y}{r^3}    \nonumber \\
a_z &=& - \frac{z}{r^3}

where the magnitude of the separation <tex>$r$</tex> is defined as

:equation:
r = \sqrt{x^2 + y^2 + z^2}

Let me start with the last line:

 :inccode: .euler.rb-6

*Carol*: Let's see whether I remember my vector analysis class.  The quantity
<tex>$\br$</tex> is called a vector, and the quantity <tex>$r$</tex> is called
a scalar, right?

*Erica*: Indeed.  The last quantity is a scalar because it is independent of
your choice of coordinate system.  If we rotate out coordinates, the values
of <tex>$x$</tex> and of <tex>$y$</tex> and of <tex>$z$</tex> may all change,
and therefore <tex>$\br$</tex> will change.  However, <tex>$r$</tex> will
stay the same, and that is a good thing: it denotes the physical distance
between the particles, something that you can measure.  When two people use
two different coordinate systems, and both measure <tex>$r$</tex>, the value
they find had better be the same.

*Dan*: My Ruby book tells me that you must add the line

 :inccode: .euler.rb-7

in order to use the square root method +sqrt+, where the term method
is used in the same way the word function is used in C and the word
subroutine is used in Fortran.  The <tt>include</tt> statement is
needed in order to gain access to the +Math+ module in Ruby, where
many of the mathematical methods reside.

*Erica*: Thanks!  Now the rest is straightforward.  To code up
Eq. (ref(axayaz)), we first need to determine <tex>$r^3$</tex>,
and a simple way to do that is to write it as a product of two
express we have already found: <tex>$r^3 = r^2r$</tex>:

 :inccode: .euler.rb-8

== Printing the Result

*Dan*: Shall we see whether the program works, so far?  Let's run it!

*Carol*: Small point, but . . . perhaps we should add a print statement,
to get the result on the screen?

*Erica*: I guess that doesn't hurt!  The Ruby syntax for printing seems to be
very intuitive, following what they call the `principle of least surprise':

 :inccode: .euler.rb-9

*Carol*: I like that principle!  And indeed, this couldn't be simpler!

*Dan*: Apart from this mysterious <tt>\n</tt> at the end.  What does that do?

*Carol*: It prints a new line.  This notation is borrowed from the C language.
By the way, I'd like to see a printout of the position and velocity at the
start of the run as well, before we enter the loop, so that we get all the
points, from start to finish.

*Erica*: Fine!  Here it is, our first program, <tt>euler.rb</tt>, which
is supposed to evolve our two-body problem for ten time units, from
<tt>t = 0</tt> till <tt>t = 10</tt>:

 :inccode: .euler.rb

