= The Modified Euler Algorithm

== A Wild Idea

*Dan*: Well, Erica, how are we going to move up to a more accurate
algorithm?

*Carol*: You mentioned something about a second-order scheme.

*Erica*: Yes, and there are several different choices.  With our
first-order approach, we had little choice.  Forward Euler was the
obvious one: just follow your nose, the way it is pointed at the 
beginning of the step, as in fig. ref(forward1).

*Dan*: You mentioned a backward Euler as well, and even drew a picture,
in in fig. ref(backward1).

*Erica*: That was only because you asked me about it!  And the backward
Euler scheme is not an explicit method.  It is an implicit method, where
you have to know the answer before give calculate it.  As we discussed, you
can solve that through iteration, but then you have to take every step
twice, and you still only have a first-order method, so there is no good
reason to use that method.

*Dan*: But wait a minute, the two types of errors in figs. ref(forward1)
and ref(backward1) are clearly going in the opposite directions.
I mean, forward flies out of the curve one way, and backwards spiral in
the other way.  I wonder, can't you somehow combine the two methods and
see whether we can let the two errors cancel each other?

If we combine the previous two pictures, the most natural thing would be
to try _both_ of the Euler types, forward and backward.  Here is a sketch,
in fig. ref(modforward1).  The top arrow is what we've done so far,
forward Euler, simply following the tangent line of the curve.  The
bottom line is backward Euler, taking a step that lands on a curve
with the right tangent at the end.  My idea is to compute both, and then
take the average between the two attempts.  I'm sure that would give a
better approximation!

:figure: modforward1.eps 6cm modforward1
An attempt to improve the Euler methods.  The top arrow shows forward Euler,
and the bottom arrow backward Euler.  The dashed arrow shows the average
between the two, which clearly gives a better approximation to the curved
lines that show the true solutions to the differential equation.

*Carol*: But at a large cost!  The backward Euler method is an implicit
method, as Erica mentioned, that requires at least one extra iteration.
So the bottom arrow alone is much more expensive to compute than the top
arrow, and we have to compute both.

*Dan*: It was just a wild idea, and it may not be useful.

== Backwards and Forwards

*Erica*: Actually, I like Dan's idea.  In reminds me of one of the second
order schemes that I learned in class.  Let me just check my notes.

Aha, I found it.  There is an algorithm called "Modified Euler", which
starts with the forward Euler idea, and then modifies it to improve the
accuracy, from first order to second order.  And it seems rather similar
to what Dan just sketched.

*Carol*: In that case, how about trying to reconstruct it for ourselves.
That is more fun than copying the algorithm from a book.

*Erica*: Okay, I'll try to forget what I learned about Modified Euler;
that will be easy to do, since I really don't remember any details any more.

Okay, how about shifting the arrow of the backwards step to the end
of the arrow of the forwards step, as in fig. ref(modforward2)?  Or to be
precise, how about just taking two forward Euler steps, one after the other?
The second forward step will not produce exactly the same arrow as the first
backward step, but it will be almost the same arrow, and perhaps such an
approximation would be good enough.

:figure: modforward2.eps 6cm modforward2
Two successive forward Euler steps.

*Dan*: But how are you going to use that to construct the dashed line in
fig. ref(modforward1)?

*Erica*: Let's see.  How about starting with fig. ref(modforward1), and
then shifting the second arrow back, so that the end of the arrow falls
on the same point as the end of the first arrow?  In that way, we have
constructed a backward Euler step that lands on the same point where our
forward Euler step landed, as you can see in fig. ref(modforward3).

:figure: modforward3.eps 6cm modforward3
A forward Euler steps and a backward Euler step, landing at the same point.

As I already admitted, the top arrow in fig. ref(modforward3) is not exactly
the same arrow as the bottow arrow in fig. ref(modforward1), but the two
arrows are approximately the same, especially if our step sizes are
not too large.  So, in a first approximation, we can average the arrows
in fig. ref(modforward3).  This will make Carol happy: no more implicit
steps.  We have only taken forward steps, even though we recycle the
second one by interpreting it as a backward step.

The simplest way to construct the average between the two vectors is by
adding them and then dividing the length by two.  Here it is, in
fig. ref(modforward4).

:figure: modforward4.eps 6cm modforward4
The new integration scheme produces the dashed arrow, as exactly one-half of
the some of the two fully drawn arrows; the dotted arrow has the same length
as the dashed arrow.  This result is approximately the same as the dashed
arrow in fig. ref(modforward1).

*Dan*: That looks like a promising approach.  Let's write a code for it.

== Specifying the Steps

*Carol*: It should be easy to implement this new scheme.  The picture
we have drawn shows the change in position of a particle, and we
should apply the same idea to the change in velocity.

For starters, let us just look at the position.  First we have to
introduce some notation.

*Erica*: In the literature, people often talk about predictor-corrector
methods.  The idea is that you first make a rough prediction about a
future position, and then you make a correction, after you have
evaluated the forces at that predicted position.

In our case, in fig. ref(modforward4), the first solid arrow starts at
the original point <tex>$\br_i$</tex>.  Let us call the end point of that
arrow <tex>$\br_{i+1, p}$</tex>, where the _p_ stands for _predicted_,
as the predicted result of taking a forward Euler step:

:equation:
\label{riplus1p}
\br_{i+1, p} = \br_i + \bv_i dt

The second arrow shows another prediction, namely for yet another
forward Euler step, which lands us at <tex>$\br_{i+2, p}$</tex>:

:equation:
\br_{i+2, p} = \br_{i+1, p} + \bv_{i+1, p} dt

*Dan*: But here you are using the velocity at time <tex>$i+1$</tex>,
something that you haven't calculated yet.

*Erica*: I know, we'll come to that in a moment, when we write down the
velocity equivalent for Eq. (ref(riplus1p)).  I just wanted to write
the position part first.  If we had <tex>$\bv_{i+1, p}$</tex>, we could
then find the _corrected_ new position by taking the average of the
first two forward Euler steps, as indicated in fig. ref(modforward4):

:eqnarray:
\label{ModEulerStepLong}
\br_{i+1, c} & = & \br_i + 
\half\left\{\left(\br_{i+1, p} - \br_i\right)+
           \left(\br_{i+2, p} - \br_{i+1, p}\right)\right\}    \nonumber \\
& = & \br_i + \half\left(\br_{i+2, p} - \br_i\right)           \nonumber \\
& = & \half\left(\br_i + \br_{i+2, p}\right)

*Carol*: As Dan pointed out, we have to do a similar thing for the velocities.
I guess that everything carries over, but with <tex>$\bv$</tex> instead
of <tex>$\br$</tex> and <tex>$\ba$</tex> instead of <tex>$\ba$</tex>.

*Erica*: Yes, in fact it is just a matter of differentiating the previous
lines with respect to time.  Putting it all together, we then get calculate
all that we need in the following order, from predicted to corrected
quantities:

:eqnarray:
\label{ModEulerStep}
\br_{i+1, p} & = & \br_i + \bv_i dt                           \nonumber \\
\bv_{i+1, p} & = & \bv_i + \ba_i dt                           \nonumber \\
\br_{i+2, p} & = & \br_{i+1, p} + \bv_{i+1, p} dt             \nonumber \\
\bv_{i+2, p} & = & \bv_{i+1, p} + \ba_{i+1, p} dt             \nonumber \\
\br_{i+1, c} & = & \half\left(\br_i + \br_{i+2, p}\right)     \nonumber \\
\bv_{i+1, c} & = & \half\left(\bv_i + \bv_{i+2, p}\right)

*Dan*: Just on time delivery, as they say: <tex>$\bv_{i+1, p}$</tex>
is calculated just before it is needed in calculating
<tex>$\br_{i+2, p}$</tex>, just as Erica correctly predicted
(no pun intended).

*Erica*: Now that I see the expressions written down in
Eq. (ref(ModEulerStep)), they suddenly seem strangely familiar.
Even though we discovered it for ourselves, I now have the feeling
I have seem them before.

*Carol*: It would be very surprising indeed, if such a straightforward
trick would not have been invented long ago.  Here, let me do a search
on the internet, with "Euler" and "generalization" . . .

. . .  uhhm, that doesn't look promising.  This guy Euler has invented
too much interesting math stuff, which others then generalized!  There
is something called an Euler line, an Euler-McLaurin formula, and it
goes on and on.  Let me add "algorithm" . . .  Still too much other stuff
. . . I'll throw in a few more words . . .

. . . aha!  Here is something that looks similar.  And not only similar,
the equations are indeed the same.  And they call it the <i>modified Euler</i>
scheme.

*Dan*: That is indeed what we did: we started with forward Euler, and modified
it by mixing in backward Euler.  We could have guessed!

== Implementation

*Carol*: Here is the new code, and now that we know the name of the algorithm,
I'll call it <tt>euler_modified_10000_steps_sparse.rb</tt>.  Let's
hope we have properly modified the original Euler:

 :inccode: .euler_modified_10000_steps_sparse.rb

== Experimentation

*Carol*: 
As you can see I am giving it time steps of size 0.001, just to be on
the safe side.  Remember, in the case of plain old forward Euler, when
we chose that step size, we got
figure ref(euler_elliptic_10000_steps_sparse_ok).  Presumably, we will
get a more accurate orbit integration this time.  Let's try it!

 :commandoutput: ruby euler_modified_10000_steps_sparse.rb > euler_modified_10000_steps_sparse.out
 :commandinput: gnuplot END
set term post eps
set output "euler_modified_10000_steps_sparse.ps"
set size ratio -1
plot "euler_modified_10000_steps_sparse.out"
quit
END

:figure: euler_modified_10000_steps_sparse.ps 10cm euler_modified_10000_steps_sparse
First attempt at modified Euler integration, with stepsize
<tex>$dt=0.001$</tex>.

Here are the results, in figure ref(euler_modified_10000_steps_sparse).

*Dan*: Wow!!!  Too good to be true.  I can't even see deviations from the
true elliptic orbit!  This is just as good as what we got for forward
Euler with a hundred times more work, in figure
ref(euler_elliptic_1000000_steps_sparse_ok).

*Erica*: fifty times more work, you mean.  In figure
ref(euler_elliptic_1000000_steps_sparse_ok), we had used time steps of 
<tex>$10^{-5}$</tex>, a hundred times smaller than the time steps of
<tex>$10^{-3}$</tex> that we used in figure ref(euler_modified_10000_steps_sparse);
but in our modified Euler case, each step requires twice as much work.

*Dan*: Ah, yes, you're right.  Well, I certainly don't mind doing twice
as much work per step, if I have to do far fewer than half the number
of steps!

== Simplification

*Carol*: Let's try to do even less work, to see how quickly things get bad.
Here, I'll make the time step that is ten times larger, in the file
<tt>euler_modified_1000_steps.rb</tt>.  This also makes life a little
simpler, because now we no longer have to sample: we can produce one
output for each step, in order to get our required one thousand outputs:

 :inccode: .euler_modified_1000_steps.rb

*Carol*: 
This approach should need just twice as much work as our very first attempt
at integrating the elliptic orbit, which resulted in failure, even
after we had corrected our initial typo, as we could see in figure ref(euler).

 :commandoutput: ruby euler_modified_1000_steps.rb > euler_modified_1000_steps.out
 :commandinput: gnuplot END
set term post eps
set output "euler_modified_1000_steps.ps"
set size ratio -1
plot "euler_modified_1000_steps.out"
quit
END

:figure: euler_modified_1000_steps.ps 10cm euler_modified_1000_steps
Second attempt at modified Euler integration, with stepsize
<tex>$dt=0.01$</tex>.

*Erica*: Again, this is far better than what we saw in figure ref(euler).
There we couldn't even complete a single orbit!
