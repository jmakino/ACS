= Reproducibility

== Making Sure

*Alice*: Now that everything seems to work, I would like to get back to
this question of reproducibility.  We have argued that we can integrate
a system for a while, get an output, and then restart a second integration
from that ouput to a finishing time, while getting the exact same result
as when we would have done a run from the beginning directly up to
this finishing time.

*Bob*: Unless we set the <tt>--exact_time</tt> flag, in which case this
no longer holds.

*Alice*: I think you're right, but I'd like to make sure.  First, I would
like to check whether we get exact conservation if we don't set the
<tt>--exact_time</tt> flag.  And then I'd like to see how much difference
it makes, if we set that flag.

*Bob*: I'm game.  It will certainly give us more confidence in our codes,
if they do what they should be doing.  But let's start at the beginning,
with the constant time step code.  Let's run it twice for one time unit,
piping the result of the first one into the second one, and once for
two time units.  We can then compare the results with our phase space
measuring rod.

We may as well take the same case we tested before, starting from the
file <tt>test.in</tt>, containing a Plummer model with five particles:

 :commandoutput: ruby nbody_cst1.rb -c 0.001 -t 1 < test.in > test01.out

Now I'll run it for another time unit, till time 2:

 :commandoutput: ruby nbody_cst1.rb -c 0.001 -t 2 < test01.out > test12.out

Hey, that is strange, it ran all the way to time 3, even though I gave it
the option <tt>-t 2</tt>.

== The Danger of Short Options

*Alice*: That shows the danger of using short options.  I bet we defined
the argument for this option to be the time _difference_, not the target
time of the integration.  Let's check:

 :commandoutput: ruby nbody_cst1.rb --help -t

*Bob*: I really like our help facility.  Helpful for sure!  Okay, I'll
try again:

 :commandoutput: ruby nbody_cst1.rb -c 0.001 -t 1 < test01.out > test12.out

And now I'll run the whole show right through from the beginning:

 :commandoutput: ruby nbody_cst1.rb -c 0.001 -t 2 < test.in > test02.out

Now _if_ everything behaves as I expect it will, we should get zero
distance in phase space:

 :commandoutput: cat test12.out test02.out | ruby acsdiff.rb

== Know Your Output File

*Alice*: Not quite.

*Bob*: That's an understatement!  The difference is huge.  What happened?

*Alice*: No idea.  But as we did before, we may have to inspect the files
again.  First, let's see what we have here:

 :commandoutput: ll test??.out

*Bob*: Ah, the file <tt>test02.out</tt> is twice as big as the others.
Of course!  By default, the integrator gives one full output per time
unit.  This means that the first file, the one we are comparing with by
default, will be the result of an integration to time 1, not 2.  That
explains!

*Alice*: If it does, we should at least get a null result in a comparison
with the first shorter run:

 :commandoutput: cat test01.out test02.out | ruby acsdiff.rb

*Bob*: And yes, that's obviously the correct explanation.  Well, let me
repeat the longer run, but this time with only one output at the end.

 :commandoutput: ruby nbody_cst1.rb -c 0.001 -t 2 -o 2 < test.in > test02.out

Wanna bet we'll get zero now?

*Alice*: I won't hold my breath.  Let's check:

 :commandoutput: cat test12.out test02.out | ruby acsdiff.rb

*Bob*: You could have held your breath, and you wouldn't have suffered!
Good, so we have reproducibility, at least for the constant time step scheme.

== Synchronization

*Alice*: Let's do a similar thing for shared time steps, first with our
<tt>exact_time</tt> option.

 :commandoutput: ruby nbody_sh1.rb -t 1 --exact_time < test.in > test01e.out
 :commandoutput: ruby nbody_sh1.rb -t 1 --exact_time < test01e.out > test12e.out
 :commandoutput: ruby nbody_sh1.rb -t 2 -o 2 --exact_time < test.in > test02e.out

== The Toll it Takes

*Bob*: According to our predictions, the composition of the first two shorter
runs should _not_ give exactly the same result as the longer runs.  Let's
check:

 :commandoutput: cat test12e.out test02e.out | ruby acsdiff.rb

Indeed, the difference is slight, but clearly noticeable.

*Alice*: Let's make sure that it's not a matter of having a different ending
time:

 :commandoutput: cat test12.out test02.out

*Bob*: No, they both end nicely at time 2.  So the difference is really a
difference between the orbits.  This is the toll that synchronisation takes!

== Asynchronicity

*Alice*: Time to check whether asynchronicity leaves things undisturbed.

 :commandoutput: ruby nbody_sh1.rb -t 1 < test.in > test01n.out
 :commandoutput: ruby nbody_sh1.rb -t 1 < test01n.out > test12n.out
 :commandoutput: ruby nbody_sh1.rb -t 2 -o 2 < test.in > test02n.out

*Bob*: So you think we'll get a smaller distance now?

*Alice*: As close to zero as we can!  I already see an encouraging sign
in the diagnostics output of the runs above.  Did you notice that the
total number of steps in the long run exactly equals the sum of the
number of steps of the two shorter runs?

*Bob*: Right you are!  Well, let's hope for the best.

 :commandoutput: cat test12n.out test02n.out | ruby acsdiff.rb

*Alice*: And the best came true.  Very nice.

== An ACS <tt>tail</tt> Version

*Bob*: You know, there is a better solution for the problem we encountered,
when we had to deal with an output file that had more than one
snapshot in it.

*Alice*: You mean in the case in which we ran a code for two time steps,
but we had forgotten that we get by default an output at every time step,
so that when we looked at the start of the file, we found the output for
time 1, rather than for time 2?

*Bob*: Yes, that was the problem.  I'm sure we'll run into this again,
often, and what we really need is a tool that picks up the _last_ ACS
object from a file, not the first one.  Normally, if you open a file
and start reading, you would read in the first ACS file first, but
instead, we need to do something like what in Unix the command +tail+
does, showing the end of a file.

*Alice*: The Unix command +tail+ has a default of showing you ten lines,
but you can ask it to show more or fewer lines, with the option <tt>-n</tt>
as in:

 :commandoutput: tail -n 3 test02n.out

which shows the last three lines.

*Bob*: Okay, let us call the file <tt>acstail.rb</tt>.  How about this?

 :inccode: .acstail.rb

*Alice*: Looks fine to me.  How about doing our previous experiment, 
without adjusting the output frequency, and using <tt>acstail.rb</tt>
instead?

*Bob*: Good idea!  Here you go.  Let's be systematic.  We know that this
works:

 :commandoutput: ruby nbody_cst1.rb -c 0.001 -t 2 -o 2 < test.in > test02.out
 :commandoutput: cat test12.out test02.out | ruby acsdiff.rb

and we also know that this doesn't work:

 :commandoutput: ruby nbody_cst1.rb -c 0.001 -t 2 < test.in > test02.out
 :commandoutput: cat test12.out test02.out | ruby acsdiff.rb

And if all is well, our new tool should be able to repair the last
problem, as follows:

 :commandoutput: ruby nbody_cst1.rb -c 0.001 -t 2 < test.in | ruby acstail.rb > test02.out
 :commandoutput: cat test12.out test02.out | ruby acsdiff.rb

*Alice*: Well done!
